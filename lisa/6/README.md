# 1

Этот код реализует алгоритм "Решето Эратосфена" для построения таблицы простых чисел, меньших заданного числа ```n```. Решето Эратосфена - это алгоритм нахождения всех простых чисел до заданного числа, и он основан на последовательном вычёркивании составных чисел.

Давайте рассмотрим код по шагам:

Инициализация массива флагов ```prime_flags```:python
```python
prime_flags = [True] * (n + 1)
```

Создается массив флагов длиной ```(n + 1)```, где каждый элемент устанавливается в ```True```. Этот массив будет использоваться для отслеживания того, является ли число простым или составным. При инициализации все числа считаются простыми.

Установка флагов для 0 и 1:python
```python
prime_flags[0] = prime_flags[1] = False
```

Поскольку 0 и 1 не являются простыми числами, их флаги устанавливаются в ```False```.

Применение алгоритма Решета Эратосфена:python
```python
for i in range(2, int(n**0.5) + 1):
    if prime_flags[i]:
        for j in range(i*i, n+1, i):
            prime_flags[j] = False
```

Проход по числам от 2 до квадратного корня из ```n```. Если флаг для числа ```i``` установлен в ```True```, то все числа в диапазоне от ```i*i``` до ```n``` с шагом ```i``` помечаются как составные (флаги устанавливаются в ```False```). Это основной момент алгоритма, который исключает составные числа.

Формирование списка простых чисел:python
```python
primes = [i for i in range(2, n+1) if prime_flags[i]]
```

Создается список ```primes```, содержащий все простые числа до ```n``` на основе флагов из массива ```prime_flags```.

Вывод результата:python
```python
return primes
```

Возвращается список простых чисел.

Использование функции для построения таблицы простых чисел меньших 256:python
```python
primes_less_than_256 = sieve_of_eratosthenes(256)
```

Функция вызывается с аргументом ```256```, и результат записывается в переменную ```primes_less_than_256```.

Вывод результата:python
```python
primes_less_than_256
```

Выводится список простых чисел, меньших 256.

Таким образом, в ```primes_less_than_256``` будет содержаться список всех простых чисел, меньших 256, полученных с использованием алгоритма Решета Эратосфена.

# 2
Этот код реализует метод Ферма для проверки простоты числа и, в случае составного числа, разложения его на множители. Давайте разберем каждую часть кода.

Метод Ферма для проверки простоты числа:python
```python
def fermat_primality_test(n, k=5):
    if n <= 1:
        return False
    elif n == 2 or n == 3:
        return True
    elif n % 2 == 0:
        return False

    for _ in range(k):
        a = random.randint(2, n - 2)
        if pow(a, n - 1, n) != 1:
            return False

    return True
```
Параметр ```n``` - число, простоту которого мы хотим проверить.Параметр ```k``` - количество итераций в методе Ферма. Значение по умолчанию установлено в 5.Сначала делаются несколько базовых проверок. Если ```n``` меньше или равно 1, то оно не является простым. Если ```n``` равно 2 или 3, то оно считается простым.Если ```n``` четное (кроме 2), то оно не является простым числом.Затем выполняется цикл с ```k``` итерациями, где для каждой итерации выбирается случайное число ```a``` в диапазоне от 2 до ```n - 2```. Если условие ```pow(a, n - 1, n) != 1``` выполняется хотя бы для одной итерации, то ```n``` считается составным числом.Если ни для одной итерации условие не выполняется, то ```n``` считается простым числом.

Функция разложения числа на множители:python
```python
def factorize(n):
    factors = []
    divisor = 2
    while divisor <= n:
        if n % divisor == 0:
            factors.append(divisor)
            n = n // divisor
        else:
            divisor += 1
    return factors
```
Параметр ```n``` - число, которое мы хотим разложить на множители.Используется метод пробного деления. Перебираются возможные делители начиная с 2.Если ```n``` делится на ```divisor``` без остатка, то ```divisor``` добавляется в список множителей, а ```n``` делится на ```divisor```.Если ```n``` не делится на ```divisor```, увеличиваем ```divisor``` на 1 и продолжаем процесс.Возвращается список множителей.

Пример использования метода Ферма:python
```python
number_to_check = 17
is_prime = fermat_primality_test(number_to_check)
if is_prime:
    print(f"{number_to_check} - простое число")
else:
    print(f"{number_to_check} - составное число, разложение на множители: {factorize(number_to_check)}")
```
Выбрано число ```17``` для проверки.Вызывается метод ```fermat_primality_test``` для проверки простоты.Если число простое, выводится сообщение об этом. В противном случае выводится сообщение о том, что число составное, и его разложение на множители получается с использованием функции ```factorize```.

Таким образом, код предоставляет пример использования метода Ферма для проверки простоты числа и разложения его на множители в случае составного числа.

# 3 
Этот код реализует несколько алгоритмов тестирования простоты числа и проводит сравнение их результатов. Давайте разберем каждую часть кода:

Тест Соловея-Штрассена (```is_strong_pseudoprime```):python
```python
def is_strong_pseudoprime(n, a):
    if n == 2:
        return True
    if n % 2 == 0 or pow(a, n-1, n) != 1:
        return False
    s, d = 0, n-1
    while d % 2 == 0:
        s += 1
        d //= 2
    x = pow(a, d, n)
    if x == 1 or x == n-1:
        return True
    for _ in range(s-1):
        x = pow(x, 2, n)
        if x == n-1:
            return True
    return False
```
Этот тест основан на теореме Соловея-Штрассена.Если ```n``` равно 2, сразу возвращается ```True```, так как 2 - простое число.Если ```n``` четное или условие ```pow(a, n-1, n) != 1``` выполняется, то ```n``` считается составным.Вычисляются значения ```s``` и ```d``` такие, что ```n - 1 = 2^s * d```.Вычисляется ```x = a^d mod n```.Если ```x``` равно 1 или ```n-1```, то ```n``` считается "псевдопростым".В цикле проверяется условие для оставшихся ```s-1``` итераций.

Тест Лемана (```lehmann_test```):python
```python
def lehmann_test(n, k=5):
    for _ in range(k):
        a = random.randint(2, n-2)
        if pow(a, (n-1)//2, n) != 1:
            return False
        if pow(a, n-1, n) != 1:
            return False
    return True
```
Этот тест использует критерий Лемана для проверки простоты числа.Генерируется случайное число ```a``` в диапазоне от 2 до ```n-2```.Проверяются два условия: ```a^((n-1)//2) mod n``` и ```a^(n-1) mod n```. Если хотя бы одно из них не выполняется, то ```n``` считается составным.

Тест Рабина-Миллера (```miller_rabin_test```):python
```python
def miller_rabin_test(n, k=5):
    if n == 2 or n == 3:
        return True
    if n % 2 == 0:
        return False
    r, s = 0, n - 1
    while s % 2 == 0:
        r += 1
        s //= 2
    for _ in range(k):
        a = random.randint(2, n - 2)
        x = pow(a, s, n)
        if x == 1 or x == n - 1:
            continue
        for _ in range(r - 1):
            x = pow(x, 2, n)
            if x == n - 1:
                break
        else:
            return False
    return True
```
Этот тест основан на тесте Рабина-Миллера.Вычисляются значения ```r``` и ```s``` такие, что ```n - 1 = 2^r * s```.Генерируется случайное число ```a``` в диапазоне от 2 до ```n-2```.Вычисляется ```x = a^s mod n```.Если ```x``` равно 1 или ```n-1```, продолжается следующая итерация.В цикле проверяется условие для оставшихся ```r-1``` итераций. Если оно не выполняется, то ```n``` считается составным.

Непосредственная проверка на простоту (```is_prime_direct```):python
```python
def is_prime_direct(n):
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True
```
Этот метод просто проверяет, является ли число ```n``` простым, используя обычную проверку делителей.

Пример использования всех тестов:python
```python
number_to_check = 104729  # Пример большого простого числа
print(f"Проверка простоты числа {number_to_check}:")

# Тест Соловея-Штрассена
print(f"Тест Соловея-Штрассена: {is_strong_pseudoprime(number_to_check, 2)}")

# Тест Лемана
print(f"Тест Лемана: {lehmann_test(number_to_check)}")

# Тест Рабина-Миллера
print(f"Тест Рабина-Миллера: {miller_rabin_test(number_to_check)}")

# Непосредственная проверка на простоту
print(f"Непосредственная проверка: {is_prime_direct(number_to_check)}")
```
Выбрано число ```104729``` для проверки.Выводятся результаты всех четырех тестов для этого числа.

Таким образом, код предоставляет инструменты для проверки простоты числа с использованием различных тестов и выводит результаты для сравнения.